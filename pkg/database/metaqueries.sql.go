// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: metaqueries.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const checkIfExists = `-- name: CheckIfExists :one
select name from exchanges where name = $1
`

func (q *Queries) CheckIfExists(ctx context.Context, name string) (string, error) {
	row := q.db.QueryRowContext(ctx, checkIfExists, name)
	err := row.Scan(&name)
	return name, err
}

const createExchange = `-- name: CreateExchange :one
INSERT INTO exchanges(id,name,code,country,currency,iso2,iso3,op_mic)
VALUES($1, $2, $3, $4, $5, $6, $7,$8)
    RETURNING id, created_at, updated_at, name, code, currency, country, iso2, iso3, op_mic
`

type CreateExchangeParams struct {
	ID       uuid.UUID
	Name     string
	Code     string
	Country  string
	Currency string
	Iso2     string
	Iso3     string
	OpMic    string
}

func (q *Queries) CreateExchange(ctx context.Context, arg CreateExchangeParams) (Exchange, error) {
	row := q.db.QueryRowContext(ctx, createExchange,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.Country,
		arg.Currency,
		arg.Iso2,
		arg.Iso3,
		arg.OpMic,
	)
	var i Exchange
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Code,
		&i.Currency,
		&i.Country,
		&i.Iso2,
		&i.Iso3,
		&i.OpMic,
	)
	return i, err
}

const createTicker = `-- name: CreateTicker :one
INSERT INTO symbols(id,code,name,exchange_name,exchange_id,currency,type)
VALUES($1,$2,$3,$4,$5,$6,$7) -- 
    RETURNING id, created_at, updated_at, code, name, exchange_name, exchange_id, currency, type
`

type CreateTickerParams struct {
	ID           uuid.UUID
	Code         string
	Name         string
	ExchangeName string
	ExchangeID   uuid.UUID
	Currency     string
	Type         string
}

func (q *Queries) CreateTicker(ctx context.Context, arg CreateTickerParams) (Symbol, error) {
	row := q.db.QueryRowContext(ctx, createTicker,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.ExchangeName,
		arg.ExchangeID,
		arg.Currency,
		arg.Type,
	)
	var i Symbol
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Code,
		&i.Name,
		&i.ExchangeName,
		&i.ExchangeID,
		&i.Currency,
		&i.Type,
	)
	return i, err
}

const fetchExchanges = `-- name: FetchExchanges :many
select id, created_at, updated_at, name, code, currency, country, iso2, iso3, op_mic from exchanges
`

func (q *Queries) FetchExchanges(ctx context.Context) ([]Exchange, error) {
	rows, err := q.db.QueryContext(ctx, fetchExchanges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exchange
	for rows.Next() {
		var i Exchange
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Code,
			&i.Currency,
			&i.Country,
			&i.Iso2,
			&i.Iso3,
			&i.OpMic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExchangeId = `-- name: GetExchangeId :one
select id from exchanges where  code= $1
`

func (q *Queries) GetExchangeId(ctx context.Context, code string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getExchangeId, code)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getTickerExchangeId = `-- name: GetTickerExchangeId :one
select exchange_id from symbols where code= $1
`

func (q *Queries) GetTickerExchangeId(ctx context.Context, code string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getTickerExchangeId, code)
	var exchange_id uuid.UUID
	err := row.Scan(&exchange_id)
	return exchange_id, err
}

const getTickerId = `-- name: GetTickerId :one
SELECT id from symbols where code = $1
`

func (q *Queries) GetTickerId(ctx context.Context, code string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getTickerId, code)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
